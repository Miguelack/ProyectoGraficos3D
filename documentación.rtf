{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang2058{\fonttbl{\f0\fnil\fcharset0 Arial;}{\f1\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\b\i\fs28\lang10 Documentaci\'f3n Proyecto Arquitectura\par

\pard\sa200\sl276\slmult1\qj\i0\fs24 Documentaci\'f3n del M\'f3dulo Cach\'e9 (src/Cache):\b0\par
El sistema de cach\'e9 implementado en nuestro proyecto de simulaci\'f3n 3D sigue un dise\'f1o set-associative que busca optimizar el acceso a los datos de geometr\'eda y texturas durante el proceso de renderizado. La arquitectura est\'e1 compuesta por tres elementos fundamentales que trabajan en conjunto para reducir los tiempos de acceso a memoria.\par
En el n\'facleo del sistema encontramos las l\'edneas de cach\'e9, que representan la unidad b\'e1sica de almacenamiento. Cada l\'ednea contiene varios campos cr\'edticos: una etiqueta que identifica el bloque de memoria que almacena, un indicador de validez que muestra si los datos actuales son utilizables, una marca de modificaci\'f3n para implementar pol\'edticas write-back en futuras versiones, y un contador de accesos que soporta el algoritmo de reemplazo LRU. Estas l\'edneas se organizan en conjuntos, cuya cantidad depende directamente de los par\'e1metros de configuraci\'f3n de la cach\'e9.\par
La inicializaci\'f3n del sistema requiere tres par\'e1metros clave: el tama\'f1o total de la cach\'e9, el tama\'f1o de cada bloque y el nivel de asociatividad. Estos valores determinan la estructura interna, calculando autom\'e1ticamente el n\'famero de conjuntos disponibles. Por ejemplo, una cach\'e9 de 32KB con bloques de 64B y 4 v\'edas de asociatividad generar\'e1 128 conjuntos distintos. Esta configuraci\'f3n permite un balance entre flexibilidad y eficiencia en el acceso a los datos.\par
Cuando el simulador necesita acceder a una direcci\'f3n de memoria espec\'edfica, el sistema de cach\'e9 ejecuta una secuencia de operaciones bien definidas. Primero determina el conjunto correspondiente mediante operaciones aritm\'e9ticas sobre la direcci\'f3n solicitada. Luego busca en todas las v\'edas del conjunto para encontrar una coincidencia con la etiqueta calculada. Si encuentra el dato, registra un acierto y actualiza los contadores LRU. En caso contrario, produce un fallo de cach\'e9 y procede a cargar el bloque desde memoria principal, reemplazando la l\'ednea menos recientemente utilizada seg\'fan el algoritmo implementado.\par
Para mejorar a\'fan m\'e1s el rendimiento, el sistema incluye un mecanismo de prefetching que anticipa la carga de bloques adyacentes al accedido recientemente. Esta t\'e9cnica aprovecha el principio de localidad espacial, cargando datos que probablemente ser\'e1n necesitados en operaciones futuras, siempre que pertenezcan al mismo conjunto de cach\'e9.\par
El subsistema ofrece herramientas de monitoreo y depuraci\'f3n que permiten verificar su funcionamiento. Es posible consultar estad\'edsticas globales y por conjunto sobre tasas de acierto, as\'ed como obtener un volcado completo del estado actual de la cach\'e9, incluyendo todas las etiquetas almacenadas y sus contadores de acceso. Esta informaci\'f3n resulta valiosa para optimizar los par\'e1metros del sistema seg\'fan las cargas de trabajo espec\'edficas del simulador 3D.\par
Actualmente, el sistema presenta algunas limitaciones que marcan el camino para futuras mejoras. Entre ellas destacan la implementaci\'f3n de pol\'edticas de escritura m\'e1s sofisticadas y la inclusi\'f3n de algoritmos de reemplazo alternativos. Tambi\'e9n se planea optimizar el dise\'f1o para entornos multin\'facleo, donde la gesti\'f3n de cach\'e9s compartidas puede ofrecer beneficios adicionales de rendimiento.\par
La integraci\'f3n de este subsistema con el simulador 3D busca principalmente acelerar las operaciones de transformaci\'f3n de v\'e9rtices y el acceso a texturas. Su configuraci\'f3n flexible permite adaptarlo a diferentes arquitecturas hardware, ajustando par\'e1metros como el tama\'f1o de bloque para que coincida con las caracter\'edsticas espec\'edficas del procesador donde se ejecute la aplicaci\'f3n.\par
\par
\b Documentaci\'f3n del M\'f3dulo de V\'e9rtices (Common/Vertice.hpp):\b0\par
Este archivo define la estructura b\'e1sica para representar v\'e9rtices en el espacio 3D dentro de nuestro motor de simulaci\'f3n. Aunque minimalista, cumple un rol fundamental en el pipeline de renderizado.\par
La estructura Vertice encapsula las tres coordenadas espaciales necesarias para definir un punto en el espacio tridimensional:\par
    x: Coordenada en el eje horizontal (derecha/izquierda)\par
    y: Coordenada en el eje vertical (arriba/abajo)\par
    z: Coordenada de profundidad (adelante/atr\'e1s)\par
Cada componente se almacena como un valor de punto flotante de precisi\'f3n simple (float), lo que proporciona un balance adecuado entre precisi\'f3n y consumo de memoria para la mayor\'eda de casos de uso en nuestro simulador.\par
El dise\'f1o deliberadamente simple permite:\par
    Interoperabilidad f\'e1cil con APIs gr\'e1ficas como OpenGL\par
    Bajo overhead al procesar grandes mallas de pol\'edgonos\par
    Flexibilidad para ser extendido cuando sea necesario (a\'f1adiendo normales, coordenadas UV, etc.)\par
La protecci\'f3n con #ifndef/#define garantiza que la definici\'f3n no cause conflictos por inclusiones m\'faltiples, una pr\'e1ctica esencial en proyectos con m\'faltiples dependencias.\par
Este componente es utilizado principalmente por:\par
    El cargador de modelos .obj\par
    Los sistemas de transformaci\'f3n geom\'e9trica\par
    El renderizador para pasar datos a la GPU\par
\par
\b Documentaci\'f3n del M\'f3dulo Generador de Datos 3D (src/DataGenerators):\b0\par
El subsistema Generador de Datos 3D proporciona herramientas fundamentales para la creaci\'f3n y an\'e1lisis de estructuras geom\'e9tricas b\'e1sicas dentro del simulador. Ubicado en el directorio src/DataGenerators, este m\'f3dulo cumple dos funciones principales: la generaci\'f3n de modelos tridimensionales primitivos y la creaci\'f3n de patrones de acceso a memoria optimizados.\par
En la parte de generaci\'f3n de modelos, el sistema ofrece m\'e9todos especializados para crear formas geom\'e9tricas elementales. La funci\'f3n para generar cubos produce los ocho v\'e9rtices necesarios para formar esta figura, posicionados sim\'e9tricamente alrededor del origen del espacio tridimensional. Cada v\'e9rtice se define con coordenadas precisas que garantizan las proporciones correctas seg\'fan el tama\'f1o especificado. De manera similar, la generaci\'f3n de pir\'e1mides crea una base cuadrada complementada con un v\'e9rtice superior, permitiendo variar tanto la extensi\'f3n de la base como la altura del \'e1pice.\par
Para facilitar el trabajo de desarrollo y depuraci\'f3n, el m\'f3dulo incluye capacidades de visualizaci\'f3n b\'e1sica. Estas permiten imprimir en consola tanto las coordenadas exactas de cada v\'e9rtice como representaciones esquem\'e1ticas en formato ASCII de las figuras generadas. Esta funcionalidad resulta particularmente valiosa para verificar r\'e1pidamente la correcta formaci\'f3n de las estructuras sin necesidad de emplear visualizadores gr\'e1ficos externos.\par
La segunda faceta importante del m\'f3dulo se centra en la generaci\'f3n de patrones de acceso a memoria. Estos patrones est\'e1n espec\'edficamente dise\'f1ados para evaluar el comportamiento del subsistema de cach\'e9, combinando accesos secuenciales que aprovechan la localidad espacial con un componente reducido de aleatoriedad. Esta combinaci\'f3n permite simular condiciones de uso m\'e1s realistas que las obtenidas con patrones puramente secuenciales o completamente aleatorios.\par
La importancia de este generador radica en su capacidad para crear condiciones controladas que permiten analizar el rendimiento del sistema de memoria bajo diferentes configuraciones. Los patrones producidos ayudan a identificar c\'f3mo variables como el tama\'f1o de bloque o el grado de asociatividad afectan la tasa de aciertos, proporcionando datos valiosos para la optimizaci\'f3n del sistema completo.\par
Cada componente del m\'f3dulo ha sido dise\'f1ado pensando en la claridad y la facilidad de uso. Los nombres descriptivos de los v\'e9rtices, las representaciones visuales sencillas y los par\'e1metros configurables hacen que esta herramienta sea accesible tanto para pruebas r\'e1pidas como para an\'e1lisis m\'e1s profundos del comportamiento del sistema. La arquitectura modular permite adem\'e1s extender las capacidades actuales mediante la incorporaci\'f3n de nuevas formas geom\'e9tricas o patrones de acceso m\'e1s sofisticados seg\'fan las necesidades del proyecto.\par
\b Documentaci\'f3n del M\'f3dulo Gr\'e1fico (src/Graficos):\b0\par
El directorio Graficos contiene los componentes centrales para la visualizaci\'f3n 3D y la interacci\'f3n de usuario en nuestro simulador. Este m\'f3dulo se encarga de gestionar todo lo relacionado con la representaci\'f3n gr\'e1fica, el manejo de la c\'e1mara virtual y la interfaz de usuario.\par
El sistema se compone de varios elementos clave. El CameraController maneja el movimiento y rotaci\'f3n de la c\'e1mara virtual, implementando controles tipo FPS con movimiento suavizado y l\'edmites de rotaci\'f3n. Trabaja en conjunto con el InputHandler que procesa las entradas de teclado y mouse, convirti\'e9ndolas en acciones para la c\'e1mara y la aplicaci\'f3n.\par
El Renderer es el n\'facleo del subsistema gr\'e1fico, encargado de transformar los modelos 3D en im\'e1genes 2D mediante proyecci\'f3n perspectiva. Implementa t\'e9cnicas como el recorte de geometr\'eda contra el plano cercano, ordenamiento por profundidad y diferentes modos de renderizado (s\'f3lido, al\'e1mbrico o mixto). Utiliza optimizaciones como el pre-c\'e1lculo de normales y la reutilizaci\'f3n de buffers.\par
El ModelViewer act\'faa como coordinador principal, integrando todos los componentes para mostrar los modelos 3D. Gestiona el bucle de renderizado, sincroniza las actualizaciones y maneja los eventos del sistema. Implementa l\'f3gica para visualizaci\'f3n tanto en modo gr\'e1fico como en consola.\par
La interfaz de usuario es manejada por UIHandler, que muestra informaci\'f3n relevante como estad\'edsticas de rendimiento, posici\'f3n de la c\'e1mara y controles disponibles. Utiliza texto renderizado con fuentes TrueType y se integra con el sistema de eventos de SFML.\par
El sistema sigue principios de dise\'f1o orientado a objetos, con responsabilidades claramente separadas. Los componentes est\'e1n dise\'f1ados para ser extensibles, permitiendo f\'e1cil incorporaci\'f3n de nuevos modos de visualizaci\'f3n o t\'e9cnicas de renderizado. El c\'f3digo hace uso intensivo de SFML para el renderizado 2D acelerado por hardware, mientras que las transformaciones 3D se implementan manualmente para mantener el control preciso sobre el pipeline gr\'e1fico.\par
La arquitectura permite visualizar diferentes modelos 3D (como cubos y pir\'e1mides) con iluminaci\'f3n b\'e1sica, mostrando simult\'e1neamente informaci\'f3n t\'e9cnica sobre el estado de la simulaci\'f3n. Todo el subsistema est\'e1 dise\'f1ado para trabajar con tasas de cuadros estables, incluso en hardware modesto, gracias a t\'e9cnicas de optimizaci\'f3n como el c\'e1lculo diferido de transformaciones y el uso eficiente de los recursos gr\'e1ficos.\par
\b Documentaci\'f3n del M\'f3dulo Principal (../principal.cpp):\b0\par
El archivo principal.cpp constituye el n\'facleo central de la aplicaci\'f3n, funcionando como punto de entrada principal y coordinador general del sistema. Este m\'f3dulo integra todos los componentes del programa gestionando el flujo de ejecuci\'f3n, la interacci\'f3n con el usuario y la coordinaci\'f3n entre los distintos subsistemas.\par
La implementaci\'f3n comienza con la inclusi\'f3n de diversas bibliotecas esenciales que proporcionan funcionalidades clave. Se incluyen componentes para manejo de tiempo, operaciones de entrada/salida, gesti\'f3n de excepciones y verificaci\'f3n de archivos. Adicionalmente, se incorporan las bibliotecas gr\'e1ficas SFML para el renderizado 2D y manejo de ventanas, junto con los m\'f3dulos personalizados del proyecto para cach\'e9, generaci\'f3n de datos y visualizaci\'f3n 3D.\par
El c\'f3digo establece varias funciones auxiliares que mejoran la experiencia de usuario y la organizaci\'f3n del programa. La funci\'f3n limpiarTerminal proporciona una forma portable de borrar la pantalla de consola, implementando l\'f3gica espec\'edfica para diferentes sistemas operativos. La funci\'f3n esperarEnter simplifica la creaci\'f3n de puntos de pausa en la interfaz de consola, mejorando la legibilidad de la salida.\par
Para la interacci\'f3n con el usuario, se implementan dos men\'fas principales. mostrarMenuPrincipal presenta las opciones globales del sistema, permitiendo acceder a las estad\'edsticas de cach\'e9, al modelado 3D o salir de la aplicaci\'f3n. mostrarMenuModelado ofrece opciones espec\'edficas para visualizaci\'f3n de figuras geom\'e9tricas tridimensionales. Ambos men\'fas incluyen validaci\'f3n robusta de entrada para garantizar una experiencia de usuario fluida.\par
La funci\'f3n mostrarEstadisticasCache se encarga de presentar informaci\'f3n detallada sobre el rendimiento del sistema de cach\'e9, incluyendo tasas de acierto y tiempo de simulaci\'f3n. cargarFuente proporciona un mecanismo para cargar tipograf\'edas desde archivo, con manejo adecuado de casos de error.\par
En la funci\'f3n main se coordina toda la ejecuci\'f3n del programa. Se inicializa el sistema de cach\'e9 con par\'e1metros predefinidos y se genera una secuencia optimizada de direcciones de memoria. El c\'f3digo mide con precisi\'f3n el tiempo de ejecuci\'f3n de la simulaci\'f3n de cach\'e9 utilizando la biblioteca chrono.\par
La aplicaci\'f3n detecta autom\'e1ticamente la disponibilidad de soporte gr\'e1fico y adapta su comportamiento en consecuencia. El bucle principal gestiona la navegaci\'f3n entre men\'fas y la ejecuci\'f3n de las diferentes funcionalidades. Para la visualizaci\'f3n 3D, se crea una ventana SFML espec\'edfica y se invoca al visualizador correspondiente seg\'fan la figura seleccionada por el usuario (cubo o pir\'e1mide).\par
El sistema incluye un manejo robusto de errores mediante bloques try-catch que capturan y presentan adecuadamente cualquier excepci\'f3n no controlada. La aplicaci\'f3n finaliza de manera controlada, devolviendo c\'f3digos de salida apropiados que indican \'e9xito o fallo en la ejecuci\'f3n.\par
El dise\'f1o modular del c\'f3digo facilita el mantenimiento y la extensi\'f3n futura, permitiendo la incorporaci\'f3n de nuevas funcionalidades con m\'ednimas modificaciones a la estructura existente. La separaci\'f3n clara de responsabilidades entre las diferentes funciones y componentes asegura un alto nivel de cohesi\'f3n y bajo acoplamiento.\f1\fs22\par
}
 